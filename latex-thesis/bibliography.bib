@inproceedings{diallo_relative_correctness_2015,
	title = {Correctness and {Relative} {Correctness}},
	volume = {2},
	doi = {10.1109/ICSE.2015.200},
	abstract = {In the process of trying to define what is a software fault, we have foundthat to formally define software faults we need to introduce the conceptof relative correctness, i.e. the property of a program to be more-correctthan another with respect to a given specification. A feature of a programis a fault (for a given specification)only because there exists an alternative to it that would makethe program more-correct with respect to the specification.In this paper, we explore applications of the concept of relative correctness in programtesting, program repair, and program design.Specifically, we argue that in many situations of software testing,fault removal and program repair, testing for relative correctnessrather than absolute correctness leads to clearer conclusions andbetter outcomes. Also, we find that designing programs by stepwisecorrectness-enhancing transformations rather than by stepwise correctness-preserving refinements leads to simpler programs and is more tolerant of designer mistakes.},
	booktitle = {2015 {IEEE}/{ACM} 37th {IEEE} {International} {Conference} on {Software} {Engineering}},
	author = {Diallo, Nafi and Ghardallou, Wided and Mili, Ali},
	year = {2015},
	keywords = {Generators, Maintenance engineering, Semantics, Software, Software engineering, Software testing},
	pages = {591--594},
}

@article{manna_axiomatic_correctness_1974,
	title = {Axiomatic approach to total correctness of programs},
	volume = {3},
	doi = {10.1007/BF00288637},
	abstract = {We present here an axiomatic approach which enables one to prove by formal methods that his program is “totally correct” (i.e., it terminates and is logically correct—does what it is supposed to do). The approach is similar to Hoare's approach [3] for proving that a program is “partially correct” (i.e., that whenever it terminates it produces correct results). Our extension to Hoare's method lies in the possibility of proving both correctness and termination by one unified formalism. One can choose to prove total correctness by a single step, or by incremental proof steps, each step establishing more properties of the program.},
	language = {en},
	number = {3},
	journal = {Acta Informatica},
	author = {Manna, Zohar and Pnueli, Amir},
	year = {1974},
	keywords = {Communication Network, Data Structure, Information System, Information Theory, Operating System},
	pages = {243--263},
}

@inproceedings{xu_how_well_static_2023,
	title = {How {Well} {Static} {Type} {Checkers} {Work} with {Gradual} {Typing}? {A} {Case} {Study} on {Python}},
	shorttitle = {How {Well} {Static} {Type} {Checkers} {Work} with {Gradual} {Typing}?},
	doi = {10.1109/ICPC58990.2023.00039},
	abstract = {Python has become increasingly popular and widely used in many fields. Dynamic features of Python provide much convenience for developers. However, they can also cause many type-related bugs undetected until runtime, which increases the cost of maintenance. Static type checking is essential to find bugs early, and the introduction of gradual typing and type annotations makes it easier to perform static type analysis. However, it remains to be investigated how well gradual typing improves real bug detection. Therefore, we conducted a comprehensive study on three widely used checkers: MyPy, PyRight, and PyType. We used a benchmark containing 10 popular Python projects with 40 real type-related bugs. First, we performed static type checking on the projects with and without type annotations to evaluate the effectiveness of finding real bugs. Second, we manually analyzed the missing bugs and investigated the reasons. The results show that the three tools can detect 29 of the 40 studied bugs after annotating, while only 14 bugs are detected before annotating. We also found that type annotations can substantially improve the ability of static type checkers to detect real bugs. A detailed analysis of bugs missed by the checkers shows that: (i) the accuracy of type analysis is challenged when it comes to programs with complicated dynamic features, such as dynamically changing object’s attributes, even with annotations; (ii) the inaccurate type annotations can undermine the ability of static type checkers to detect real bugs; (iii) static type checkers have different checking strategies in some cases, which has an impact on real bug detection. Our study can not only enable developers to better understand static type checking and make better use of them but also guide future research.},
	booktitle = {2023 {IEEE}/{ACM} 31st {International} {Conference} on {Program} {Comprehension} ({ICPC})},
	author = {Xu, Wenjie and Chen, Lin and Su, Chenghao and Guo, Yimeng and Li, Yanhui and Zhou, Yuming and Xu, Baowen},
	keywords = {Annotations, Benchmark testing, bug detection, Computer bugs, Costs, Feature extraction, gradual typing, Maintenance engineering, Python, Runtime, static type checking, type annotation},
	pages = {242--253},
    year={2023},
	file = {IEEE Xplore Full Text PDF:/Users/xylix/Zotero/storage/JCA3ZI4E/Xu et al. - 2023 - How Well Static Type Checkers Work with Gradual Ty.pdf:application/pdf},
}

@misc{pyright_type_inference,
	title = {Type {Inference}},
    author={Microsoft},
	url = {https://microsoft.github.io/pyright/#/type-inference},
	urldate = {2024-12-13},
	file = {Type Inference:/Users/xylix/Zotero/storage/M32YMXPZ/pyright.html:text/html},
}

@misc{mypy_type_inference,
	title = {Type inference and type annotations - mypy 1.13.0 documentation},
    author={Jukka Lehtosalo and mypy contributors},
	url = {https://mypy.readthedocs.io/en/stable/type_inference_and_annotations.html},
	urldate = {2024-12-13},
	file = {Type inference and type annotations - mypy 1.13.0 documentation:/Users/xylix/Zotero/storage/3UPRMWGP/type_inference_and_annotations.html:text/html},
}

@inproceedings{jin_where_to_start_2021,
	title = {Where to {Start}: {Studying} {Type} {Annotation} {Practices} in {Python}},
	shorttitle = {Where to {Start}},
	doi = {10.1109/ASE51524.2021.9678947},
	abstract = {Dynamic programming languages have been embracing gradual typing, which supports optional type annotations in source code. Type-annotating a complex and long-lasting codebase is indeed a gradual and expensive process, where two issues have troubled developers. First, there is few guidance about how to implement type annotations due to the existence of non-trivial type practices; second, there is few guidance about which portion of a codebase should be type-annotated first. To address these issues, this paper investigates the patterns of non-trivial type-annotation practices and features of type-annotated code files. Our study detected six patterns of type-annotation practices, which involve recovering and expressing design concerns. Moreover, we revealed three complementary features of type-annotated files. Besides, we implemented a tool for studying optional typing practice. We suggest that: 1) design concerns should be considered to improve type annotation implementation by following at least six patterns; 2) files critical to software architecture could be type-annotated in priority. We believe these guidelines would promote a better type annotation practice for dynamic languages.},
	booktitle = {2021 36th {IEEE}/{ACM} {International} {Conference} on {Automated} {Software} {Engineering} ({ASE})},
	author = {Jin, Wuxia and Zhong, Dinghong and Ding, Zifan and Fan, Ming and Liu, Ting},
	keywords = {Annotations, Codes, Costs, dynamic languages, Dynamic programming, Feature extraction, Maintenance engineering, Software architecture, type annotation},
	pages = {529--541},
}

@inproceedings{gao_to_type_or_not_2017,
	title = {To {Type} or {Not} to {Type}: {Quantifying} {Detectable} {Bugs} in {JavaScript}},
	shorttitle = {To {Type} or {Not} to {Type}},
	doi = {10.1109/ICSE.2017.75},
	abstract = {JavaScript is growing explosively and is now used in large mature projects even outside the web domain. JavaScript is also a dynamically typed language for which static type systems, notably Facebook's Flow and Microsoft's TypeScript, have been written. What benefits do these static type systems provide? Leveraging JavaScript project histories, we select a fixed bug and check out the code just prior to the fix. We manually add type annotations to the buggy code and test whether Flow and TypeScript report an error on the buggy code, thereby possibly prompting a developer to fix the bug before its public release. We then report the proportion of bugs on which these type systems reported an error. Evaluating static type systems against public bugs, which have survived testing and review, is conservative: it understates their effectiveness at detecting bugs during private development, not to mention their other benefits such as facilitating code search/completion and serving as documentation. Despite this uneven playing field, our central finding is that both static type systems find an important percentage of public bugs: both Flow 0.30 and TypeScript 2.0 successfully detect 15\%!.},
	booktitle = {2017 {IEEE}/{ACM} 39th {International} {Conference} on {Software} {Engineering} ({ICSE})},
	author = {Gao, Zheng and Bird, Christian and Barr, Earl T.},
	keywords = {Computer bugs, Documentation, Facebook, Flow, History, JavaScript, Measurement uncertainty, mining software repositories, Software, static type systems, Surgery, TypeScript},
	pages = {758--769},
	file = {IEEE Xplore Abstract Record:/Users/xylix/Zotero/storage/S4F4XPLT/7985711.html:text/html;IEEE Xplore Full Text PDF:/Users/xylix/Zotero/storage/4PPC74PQ/Gao et al. - 2017 - To Type or Not to Type Quantifying Detectable Bug.pdf:application/pdf},
}

@misc{python_software_foundation_jetbrains_sro_python_nodate,
	title = {Python {Developers} {Survey} 2023 {Results}},
	url = {https://lp.jetbrains.com/python-developers-survey-2023/},
	abstract = {Official Python Developers Survey 2023 Results by Python Software Foundation and JetBrains: more than 25k responses from almost 200 countries.},
	language = {en},
	urldate = {2024-12-06},
	journal = {JetBrains: Developer Tools for Professionals and Teams},
	author = {{Python Software Foundation, JetBrains s.r.o}},
	file = {Snapshot:/Users/xylix/Zotero/storage/8WJZ84UV/python-developers-survey-2023.html:text/html},
}


@misc{jetbrains_type_hinting_pycharm,
	title = {Type hinting in {PyCharm} {\textbar} {PyCharm}},
	url = {https://www.jetbrains.com/help/pycharm/type-hinting-in-product.html},
	language = {en-US},
	urldate = {2024-12-06},
	journal = {PyCharm Help},
	author = {{JetBrains s.r.o}},
	file = {Snapshot:/Users/xylix/Zotero/storage/6VHFXNJA/type-hinting-in-product.html:text/html},
    
}
@inproceedings{cardelli_typeful_1989,
	title = {Typeful {Programming}},
	booktitle = {Formal {Description} of {Programming} {Concepts}, IFIP State of the Art Reports Series},
    publisher={Springer-Verlag},
	author = {Cardelli, Luca},
	year = {1989},
    url = {http://lucacardelli.name/Papers/TypefulProg.A4.pdf},
    isbn = {978-3-540-53961-2},
}


@inproceedings{lin_towards_large_scale_2023,
	title = {Towards a {Large}-{Scale} {Empirical} {Study} of {Python} {Static} {Type} {Annotations}},
	doi = {10.1109/SANER56733.2023.00046},
	abstract = {Python, as one of the most popular and important programming languages in the era of data science, has recently introduced a syntax for static type annotations with PEP 484, to improve code maintainability, quality, and readability. However, it is still unknown whether and how static type annotations are used in practical Python projects.This paper presents, to the best of our knowledge, the first and most comprehensive empirical study on the defects, evolution and rectification of static type annotations in Python projects. We first designed and implemented a software prototype dubbed PYSCAN, then used it to scan notable Python projects with diverse domains and sizes and type annotation manners, which add up to 19,478,428 lines of Python code. The empirical results provide interesting findings and insights, such as: 1) we proposed a taxonomy of Python type annotation-related defects, by classifying defects into four categories; 2) we investigated the evolution of type annotation-related defects; and 3) we proposed automatic defect rectification strategies, generating rectification suggestions for 82 out of 110 (74.55\%) defects successfully. We suggest that: 1) Python language designers should clarify the type annotation specification; 2) checking tool builders should improve their tools to suppress false positives; and 3) Python developers should integrate such checking tools into their development workflow to catch type annotation-related defects at an early development stage.We have reported our findings and suggestions to Python language designers, checking tool builders, and Python developers. They have acknowledged us and taken actions based on our suggestions. We believe these guidelines would improve static type annotation practices and benefit the Python ecosystem in general.},
	booktitle = {2023 {IEEE} {International} {Conference} on {Software} {Analysis}, {Evolution} and {Reengineering} ({SANER})},
	author = {Lin, Xinrong and Hua, Baojian and Wang, Yang and Pan, Zhizhong},
	keywords = {Annotations, Codes, Data science, Ecosystems, Empirical Study, Prototypes, Python, Static Type Annotations, Syntactics, Taxonomy},
	pages = {414--425},
	file = {Full Text PDF:/Users/xylix/Zotero/storage/PD5MUEZ7/Lin et al. - 2023 - Towards a Large-Scale Empirical Study of Python St.pdf:application/pdf;IEEE Xplore Abstract Record:/Users/xylix/Zotero/storage/FY8IVMMJ/10123628.html:text/html},
}

@inproceedings{nanz_comparative_2015,
	title = {A {Comparative} {Study} of {Programming} {Languages} in {Rosetta} {Code}},
	volume = {1},
	doi = {10.1109/ICSE.2015.90},
	abstract = {Sometimes debates on programming languages are more religious than scientific. Questions about which language is more succinct or efficient, or makes developers more productive are discussed with fervor, and their answers are too often based on anecdotes and unsubstantiated beliefs. In this study, we use the largely untapped research potential of Rosetta Code, a code repository of solutions to common programming tasks in various languages, which offers a large data set for analysis. Our study is based on 7'087 solution programs corresponding to 745 tasks in 8 widely used languages representing the major programming paradigms (procedural: C and Go, object-oriented: C\# and Java, functional: F\# and Haskell, scripting: Python and Ruby). Our statistical analysis reveals, most notably, that: functional and scripting languages are more concise than procedural and object-oriented languages, C is hard to beat when it comes to raw speed on large inputs, but performance differences over inputs of moderate size are less pronounced and allow even interpreted languages to be competitive, compiled strongly-typed languages, where more defects can be caught at compile time, are less prone to runtime failures than interpreted or weakly-typed languages. We discuss implications of these results for developers, language designers, and educators.},
	booktitle = {2015 {IEEE}/{ACM} 37th {IEEE} {International} {Conference} on {Software} {Engineering}},
	author = {Nanz, Sebastian and Furia, Carlo A.},
	year = {2015},
	keywords = {Indexes, Java, Programming, Runtime, Standards, Statistical analysis},
	pages = {778--788},
	file = {Full Text PDF:/Users/xylix/Zotero/storage/NIUQUW2M/Nanz and Furia - 2015 - A Comparative Study of Programming Languages in Ro.pdf:application/pdf;IEEE Xplore Abstract Record:/Users/xylix/Zotero/storage/SLQ54NUI/7194625.html:text/html},
}

@article{siek_refined_gradual_2015,
	title = {Refined {Criteria} for {Gradual} {Typing}},
	volume = {32},
	copyright = {Creative Commons Attribution 3.0 Unported license, info:eu-repo/semantics/openAccess},
	doi = {10.4230/LIPICS.SNAPL.2015.274},
	abstract = {Siek and Taha [2006] coined the term gradual typing to describe a theory for integrating static and dynamic typing within a single language that 1) puts the programmer in control of which regions of code are statically or dynamically typed and 2) enables the gradual evolution of code between the two typing disciplines. Since 2006, the term gradual typing has become quite popular but its meaning has become diluted to encompass anything related to the integration of static and dynamic typing. This dilution is partly the fault of the original paper, which provided an incomplete formal characterization of what it means to be gradually typed. In this paper we draw a crisp line in the sand that includes a new formal property, named the gradual guarantee, that relates the behavior of programs that diﬀer only with respect to their type annotations. We argue that the gradual guarantee provides important guidance for designers of gradually typed languages. We survey the gradual typing literature, critiquing designs in light of the gradual guarantee. We also report on a mechanized proof that the gradual guarantee holds for the Gradually Typed Lambda Calculus.},
	language = {en},
	journal = {LIPIcs, Volume 32, SNAPL 2015},
	author = {Siek, Jeremy G. and Vitousek, Michael M. and Cimini, Matteo and Boyland, John Tang},
	collaborator = {Ball, Thomas and Bodik, Rastislav and Krishnamurthi, Shriram and Lerner, Benjamin S. and Morrisett, Greg},
	year = {2015},
	keywords = {dynamic languages, gradual typing, semantics, type systems},
	pages = {274--293},
	file = {Siek et al. - 2015 - Refined Criteria for Gradual Typing.pdf:/Users/xylix/Zotero/storage/CVL4GHZN/Siek et al. - 2015 - Refined Criteria for Gradual Typing.pdf:application/pdf},
}

@inproceedings{rak-amnouykit_taleoftwo_2020,
	address = {Virtual USA},
	title = {Python 3 types in the wild: a tale of two type systems},
	isbn = {978-1-4503-8175-8},
	shorttitle = {Python 3 types in the wild},
	doi = {10.1145/3426422.3426981},
	abstract = {Python 3 is a highly dynamic language, but it has introduced a syntax for expressing types with PEP484. This paper explores how developers use these type annotations, the type system semantics provided by type checking and inference tools, and the performance of these tools. We evaluate the types and tools on a corpus of public GitHub repositories. We review MyPy and PyType, two canonical static type checking and inference tools, and their distinct approaches to type analysis. We then address three research questions: (i) How often and in what ways do developers use Python 3 types? (ii) Which type errors do developers make? (iii) How do type errors from different tools compare? Surprisingly, when developers use static types, the code rarely type-checks with either of the tools. MyPy and PyType exhibit false positives, due to their static nature, but also flag many useful errors in our corpus. Lastly, MyPy and PyType embody two distinct type systems, flagging different errors in many cases. Understanding the usage of Python types can help guide tool-builders and researchers. Understanding the performance of popular tools can help increase the adoption of static types and tools by practitioners, ultimately leading to more correct and more robust Python code.},
	language = {en},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} {International} {Symposium} on {Dynamic} {Languages}},
	publisher = {ACM},
	author = {Rak-amnouykit, Ingkarat and McCrevan, Daniel and Milanova, Ana and Hirzel, Martin and Dolby, Julian},
	year = {2020},
	pages = {57--70},
	file = {Rak-amnouykit et al. - 2020 - Python 3 types in the wild a tale of two type sys.pdf:/Users/xylix/Zotero/storage/2AHGQ5WB/Rak-amnouykit et al. - 2020 - Python 3 types in the wild a tale of two type sys.pdf:application/pdf},
}

@misc{pydanticdev_welcome_nodate,
	title = {Welcome to {Pydantic} - {Pydantic}},
	url = {https://docs.pydantic.dev/latest/},
	abstract = {Data validation using Python type hints},
	language = {en},
	urldate = {2024-10-30},
	author = {{pydantic.dev}},
	file = {Snapshot:/Users/xylix/Zotero/storage/GJEYEKMW/latest.html:text/html},
}   

@misc{python_typing,
	title = {typing — {Support} for type hints},
    author = "{Python Software Foundation}",
	url = {https://docs.python.org/3/library/typing.html},
	abstract = {Source code: Lib/typing.py This module provides runtime support for type hints. Consider the function below: The function surface\_area\_of\_cube takes an argument expected to be an instance of float,...},
	language = {en},
	urldate = {2024-10-30},
	journal = {Python documentation},
	file = {Snapshot:/Users/xylix/Zotero/storage/S88EW55K/typing.html:text/html},
}

@inproceedings{di_grazia_evolution_2022,
	address = {Singapore},
	title = {The evolution of type annotations in python: an empirical study},
	shorttitle = {The evolution of type annotations in python},
	doi = {10.1145/3540250.3549114},
	abstract = {Type annotations and gradual type checkers attempt to reveal errors and facilitate maintenance in dynamically typed programming languages. Despite the availability of these features and tools, it is currently unclear how quickly developers are adopting them, what strategies they follow when doing so, and whether adding type annotations reveals more type errors. This paper presents the first large-scale empirical study of the evolution of type annotations and type errors in Python. The study is based on an analysis of 1,414,936 type annotation changes, which we extract from 1,123,393 commits among 9,655 projects. Our results show that (i) type annotations are getting more popular, and once added, often remain unchanged in the projects for a long time, (ii) projects follow three evolution patterns for type annotation usage ś regular annotation, type sprints, and occasional uses ś and that the used pattern correlates with the number of contributors, (iii) more type annotations help find more type errors (0.704 correlation), but nevertheless, many commits (78.3\%) are committed despite having such errors. Our findings show that better developer training and automated techniques for adding type annotations are needed, as most code still remains unannotated, and they call for a better integration of gradual type checking into the development process.},
	language = {en},
	booktitle = {Proceedings of the 30th {ACM} {Joint} {European} {Software} {Engineering} {Conference} and {Symposium} on the {Foundations} of {Software} {Engineering}},
	publisher = {ACM},
	author = {Di Grazia, Luca and Pradel, Michael},
	year = {2022},
	pages = {209--220},
	file = {Di Grazia and Pradel - 2022 - The evolution of type annotations in python an em.pdf:/Users/xylix/Zotero/storage/3332KWX7/Di Grazia and Pradel - 2022 - The evolution of type annotations in python an em.pdf:application/pdf},
}

@article{ray_codequality_2014,
	title = {A {Large} {Scale} {Study} of {Programming} {Languages} and {Code} {Quality} in {Github}},
	doi = {10.1145/2635868.2635922},
	abstract = {What is the effect of programming languages on software quality? This question has been a topic of much debate for a very long time. In this study, we gather a very large data set from GitHub (729 projects, 80 Million SLOC, 29,000 authors, 1.5 million commits, in 17 languages) in an attempt to shed some empirical light on this question. This reasonably large sample size allows us to use a mixed-methods approach, combining multiple regression modeling with visualization and text analytics, to study the effect of language features such as static v.s. dynamic typing, strong v.s. weak typing on software quality. By triangulating ﬁndings from different methods, and controlling for confounding effects such as team size, project size, and project history, we report that language design does have a signiﬁcant, but modest effect on software quality. Most notably, it does appear that strong typing is modestly better than weak typing, and among functional languages, static typing is also somewhat better than dynamic typing. We also ﬁnd that functional languages are somewhat better than procedural languages. It is worth noting that these modest effects arising from language design are overwhelmingly dominated by the process factors such as project size, team size, and commit size. However, we hasten to caution the reader that even these modest effects might quite possibly be due to other, intangible process factors, e.g., the preference of certain personality types for functional, static and strongly typed languages.},
	language = {en},
	author = {Ray, Baishakhi and Posnett, Daryl and Filkov, Vladimir and Devanbu, Premkumar},
	year = {2014},
	file = {Ray et al. - A Large Scale Study of Programming Languages and C.pdf:/Users/xylix/Zotero/storage/HZBYBHBD/Ray et al. - A Large Scale Study of Programming Languages and C.pdf:application/pdf},
}

@article{codequality_reproudction_2019,
	title = {On the {Impact} of {Programming} {Languages} on {Code} {Quality}: {A} {Reproduction} {Study}},
	volume = {41},
	shorttitle = {On the {Impact} of {Programming} {Languages} on {Code} {Quality}},
	doi = {10.1145/3340571},
	abstract = {In a 2014 article, Ray, Posnett, Devanbu, and Filkov claimed to have uncovered a statistically significant association between 11 programming languages and software defects in 729 projects hosted on GitHub. Specifically, their work answered four research questions relating to software defects and programming languages. With data and code provided by the authors, the present article first attempts to conduct an experimental repetition of the original study. The repetition is only partially successful, due to missing code and issues with the classification of languages. The second part of this work focuses on their main claim, the association between bugs and languages, and performs a complete, independent reanalysis of the data and of the statistical modeling steps undertaken by Ray et al. in 2014. This reanalysis uncovers a number of serious flaws that reduce the number of languages with an association with defects down from 11 to only 4. Moreover, the practical effect size is exceedingly small. These results thus undermine the conclusions of the original study. Correcting the record is important, as many subsequent works have cited the 2014 article and have asserted, without evidence, a causal link between the choice of programming language for a given task and the number of software defects. Causation is not supported by the data at hand; and, in our opinion, even after fixing the methodological flaws we uncovered, too many unaccounted sources of bias remain to hope for a meaningful comparison of bug rates across languages.},
	language = {en},
	number = {4},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Berger, Emery D. and Hollenbeck, Celeste and Maj, Petr and Vitek, Olga and Vitek, Jan},
	year = {2019},
	file = {Berger et al. - 2019 - On the Impact of Programming Languages on Code Qua.pdf:/Users/xylix/Zotero/storage/NDJ7C8VG/Berger et al. - 2019 - On the Impact of Programming Languages on Code Qua.pdf:application/pdf},
}

@article{khan_empirical_2022,
	title = {An {Empirical} {Study} of {Type}-{Related} {Defects} in {Python} {Projects}},
	volume = {48},
	doi = {10.1109/TSE.2021.3082068},
	number = {8},
	journal = {IEEE Transactions on Software Engineering},
	author = {Khan, Faizan and Chen, Boqi and Varro, Daniel and McIntosh, Shane},
	year = {2022},
	keywords = {Python, Annotations, dynamic type systems, Ecosystems, empirical study, Software defects, Software measurement, Software systems, static type checkers, Task analysis, Tools},
	pages = {3145--3158},
	file = {IEEE Xplore Abstract Record:/Users/xylix/Zotero/storage/QQ58BNSK/9436020.html:text/html;IEEE Xplore Full Text PDF:/Users/xylix/Zotero/storage/FPNQUXFS/Khan et al. - 2022 - An Empirical Study of Type-Related Defects in Pyth.pdf:application/pdf},
}

@misc{pep_484,
	title = {{PEP} 484 – {Type} {Hints}},
	url = {https://peps.python.org/pep-0484/},
	abstract = {PEP 3107 introduced syntax for function annotations, but the semantics were deliberately left undefined.  There has now been enough 3rd party usage for static type analysis that the community would benefit from a standard vocabulary and baseline tools w...},
	language = {en},
	urldate = {2024-10-22},
	journal = {Python Enhancement Proposals (PEPs)},
	author = {{Guido van Rossum, Jukka Lehtosalo, Łukasz Langa}},
	month = sep,
	year = {2014},
	file = {Snapshot:/Users/xylix/Zotero/storage/8IL72DYT/pep-0484.html:text/html},
}

@INBOOK{programming_langs,
	address = {London},
	series = {Undergraduate {Topics} in {Computer} {Science}},
	title = {Programming {Languages}: {Principles} and {Paradigms}},
	copyright = {https://www.springernature.com/gp/researchers/text-and-data-mining},
	shorttitle = {Programming {Languages}},
	language = {en},
	publisher = {Springer London},
	author = {Gabbrielli, Maurizio and Martini, Simone},
	year = {2010},
	doi = {10.1007/978-1-84882-914-5},
    PAGES = "197-262",
}